# Proto2FFI

**Service-Oriented FFI Code Generation from Protocol Buffers for Dart & Rust**

[![Crates.io](https://img.shields.io/crates/v/proto2ffi)](https://crates.io/crates/proto2ffi)
[![Documentation](https://docs.rs/proto2ffi/badge.svg)](https://docs.rs/proto2ffi)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)

Proto2FFI generates high-performance FFI bindings between Dart and Rust from protobuf service definitions. Think gRPC, but for FFI. Perfect for Flutter plugins, native extensions, and high-performance applications.

## âœ¨ Features

- **ğŸš€ Service-Based**: Define RPC services in proto files, get clean FFI bindings
- **âš¡ High Performance**: Protobuf encoding proven 16-18% faster than raw struct conversion
- **ğŸ”’ Memory Safe**: Proper protobuf encoding with automatic memory management
- **ğŸ› ï¸ Type Safe**: Generated code is fully type-safe in both languages
- **ğŸ“ Protocol Buffers**: Use familiar .proto service definitions
- **ğŸ¯ Zero Boilerplate**: Auto-generated FFI glue, clean client APIs
- **ğŸ“¦ Compact**: 5-15x smaller than fixed-size structs (216 bytes vs 1200 bytes)
- **ğŸ”„ Standard**: Works with any protobuf tooling

## ğŸ¯ Why Proto2FFI?

**The Problem:** Manual FFI bindings are tedious, error-prone, and require writing boilerplate for every function call.

**The Solution:** Define your service interface once in proto, generate all the FFI glue automatically.

### Performance: Protobuf vs Raw Structs

Based on comprehensive benchmarks (see `research/proto_benchmark/`):

| Approach | Single Operation | Bulk (1000 msgs) | Memory |
|----------|------------------|------------------|--------|
| **Protobuf-over-FFI** | **14.3 Î¼s** | **2.20 Î¼s/msg** | **216 bytes** |
| Raw FFI Structs | 17.6 Î¼s | 2.69 Î¼s/msg | 1200 bytes |
| **Advantage** | **18% faster** | **18% faster** | **5.5x smaller** |

Protobuf encoding is faster than field-by-field struct copying due to:
- Optimized varint encoding
- Zero-copy where possible
- No string allocation overhead per field
- Better CPU cache utilization

## ğŸš€ Quick Start

### Installation

```bash
cargo install proto2ffi
```

### Basic Usage

**1. Define your service** (`greeter.proto`):

```protobuf
syntax = "proto3";

package greeter;

message HelloRequest {
  string name = 1;
}

message HelloResponse {
  string message = 1;
}

service Greeter {
  rpc SayHello(HelloRequest) returns (HelloResponse);
}
```

**2. Generate bindings**:

```bash
proto2ffi generate \
  --proto greeter.proto \
  --rust-out rust_service/src/generated \
  --dart-out dart_client/lib/generated
```

**3. Implement service in Rust**:

```rust
// Build protobuf messages with prost
mod proto {
    include!("proto/greeter.rs"); // Generated by prost-build
}

pub use proto::{HelloRequest, HelloResponse};

mod generated; // Generated by proto2ffi
use generated::*;

struct GreeterService;

impl Greeter for GreeterService {
    fn say_hello(&self, request: HelloRequest) -> Result<HelloResponse, Box<dyn std::error::Error>> {
        let message = format!("Hello, {}!", request.name);
        Ok(HelloResponse { message })
    }
}

#[no_mangle]
pub extern "C" fn init_service() {
    unsafe {
        init_greeter(Box::new(GreeterService));
    }
}
```

**4. Build as cdylib**:

```toml
[lib]
crate-type = ["cdylib"]

[dependencies]
prost = "0.12"

[build-dependencies]
prost-build = "0.12"
```

```rust
// build.rs
fn main() {
    prost_build::Config::new()
        .out_dir("src/proto")
        .compile_protos(&["proto/greeter.proto"], &["proto"])
        .unwrap();
}
```

```bash
cargo build --release
```

**5. Use in Dart**:

```dart
import 'dart:ffi' as ffi;
import 'package:ffi/ffi.dart';
import 'generated/proto2ffi_generated.dart';
import 'package:greeter/greeter.pb.dart'; // Generated by protoc

void main() {
  // Load library
  final dylib = ffi.DynamicLibrary.open('libgreeter.dylib');

  // Initialize service
  final initService = dylib.lookupFunction<
    ffi.Void Function(),
    void Function()
  >('init_service');
  initService();

  // Create client
  final client = GreeterClient(dylib);

  // Make RPC call
  final request = HelloRequest()..name = 'World';
  final responseBytes = client.say_hello(request.writeToBuffer());

  if (responseBytes != null) {
    final response = HelloResponse.fromBuffer(responseBytes);
    print(response.message); // "Hello, World!"
  }
}
```

## ğŸ“Š How It Works

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  .proto Service â”‚  Define RPC interface
â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
         â”‚ proto2ffi generate
         â–¼
    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚                 â”‚
    â–¼                 â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Rust FFI     â”‚  â”‚ Dart Client  â”‚
â”‚ - Traits     â”‚  â”‚ - Clean API  â”‚
â”‚ - Exports    â”‚  â”‚ - ByteBuffer â”‚
â”‚ - ByteBuffer â”‚  â”‚ - FFI calls  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

Runtime: Protobuf encode/decode on both sides
```

### Under the Hood

**Dart â†’ Rust:**
1. Dart: Encode protobuf message â†’ `Uint8List`
2. Dart: Pass pointer to Rust via FFI
3. Rust: Decode protobuf â†’ Process â†’ Encode response
4. Rust: Return pointer to response bytes
5. Dart: Decode protobuf response

**Why This Works:**
- Protobuf encoding is fast (3-4 Î¼s)
- Pointer passing is zero-cost
- No field-by-field copying overhead
- Compact memory representation

## ğŸ¯ Architecture

### Generated Rust Code

**Service Trait:**
```rust
pub trait Greeter {
    fn say_hello(&self, request: HelloRequest)
        -> Result<HelloResponse, Box<dyn std::error::Error>>;
}
```

**FFI Exports:**
```rust
#[no_mangle]
pub unsafe extern "C" fn proto2ffi_say_hello(
    request_data: *const u8,
    request_len: usize
) -> ByteBuffer {
    // Decode protobuf request
    // Call service trait method
    // Encode protobuf response
    // Return ByteBuffer
}
```

**ByteBuffer:**
```rust
#[repr(C)]
pub struct ByteBuffer {
    pub ptr: *mut u8,
    pub len: usize,
    pub cap: usize,
}
```

### Generated Dart Code

**Client:**
```dart
class GreeterClient {
  final ffi.DynamicLibrary _dylib;

  List<int>? say_hello(List<int> requestBytes) {
    // Allocate memory for request
    // Call FFI function
    // Extract response bytes
    // Free memory
    // Return response
  }
}
```

## ğŸ“š Examples

### Hello World

See `examples/hello_world/` for a complete working example:

```
examples/hello_world/
â”œâ”€â”€ proto/
â”‚   â””â”€â”€ hello.proto              # Service definition
â”œâ”€â”€ rust_service/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ lib.rs              # Service implementation
â”‚   â”‚   â”œâ”€â”€ proto/              # Protobuf generated (prost)
â”‚   â”‚   â””â”€â”€ generated/          # FFI generated (proto2ffi)
â”‚   â””â”€â”€ Cargo.toml
â””â”€â”€ dart_client/
    â”œâ”€â”€ lib/
    â”‚   â””â”€â”€ generated/          # Client generated (proto2ffi)
    â””â”€â”€ pubspec.yaml
```

## ğŸ”§ CLI Usage

```bash
proto2ffi generate [OPTIONS]

Options:
  -p, --proto <FILE>          Proto file to parse
  -r, --rust-out <DIR>        Output directory for Rust code
  -d, --dart-out <DIR>        Output directory for Dart code
  -i, --includes <DIR>...     Include paths for proto imports
  -h, --help                  Print help
  -V, --version               Print version
```

### Example:

```bash
proto2ffi generate \
  --proto services/user.proto \
  --proto services/auth.proto \
  --rust-out backend/src/generated \
  --dart-out app/lib/generated \
  --includes services \
  --includes third_party/protos
```

## ğŸ¨ Advanced Features

### Multiple Services

```protobuf
service UserService {
  rpc GetUser(GetUserRequest) returns (GetUserResponse);
  rpc CreateUser(CreateUserRequest) returns (CreateUserResponse);
}

service AuthService {
  rpc Login(LoginRequest) returns (LoginResponse);
  rpc Logout(LogoutRequest) returns (LogoutResponse);
}
```

Each service gets its own trait and client.

### Complex Messages

```protobuf
message User {
  uint64 id = 1;
  string name = 2;
  string email = 3;
  repeated string tags = 4;
  map<string, string> metadata = 5;

  message Address {
    string street = 1;
    string city = 2;
  }
  Address address = 6;
}
```

All protobuf features are supported (nested messages, repeated, maps, etc).

### Error Handling

```rust
impl UserService for MyService {
    fn get_user(&self, req: GetUserRequest)
        -> Result<GetUserResponse, Box<dyn std::error::Error>>
    {
        if req.id == 0 {
            return Err("Invalid user ID".into());
        }

        // Returns null on Dart side if error occurs
        Ok(GetUserResponse { /* ... */ })
    }
}
```

## ğŸ“ˆ Performance Benchmarks

### Single Operation (Individual Messages)

```
User Message (216 bytes):
  Protobuf-over-FFI: 14.3 Î¼s average  âœ“ 18% faster
  Raw FFI Structs:   17.6 Î¼s average
```

### Bulk Operations (1000 Messages)

```
User Messages:
  Protobuf-over-FFI: 2.20 Î¼s/msg  âœ“ 18% faster
  Raw FFI Structs:   2.69 Î¼s/msg

Post Messages:
  Protobuf-over-FFI: 2.20 Î¼s/msg  âœ“ 18% faster
  Raw FFI Structs:   2.69 Î¼s/msg
```

### Memory Efficiency

```
User Message:
  Protobuf: 216 bytes   âœ“ 5.5x smaller
  Raw FFI:  1200 bytes

Post Message:
  Protobuf: 307 bytes   âœ“ 14.6x smaller
  Raw FFI:  4480 bytes
```

**Key Findings:**
- Protobuf encoding beats field-by-field struct copying
- String allocation overhead dominates raw FFI (80% of cost)
- Variable-length encoding is more efficient than fixed arrays
- Better CPU cache utilization with smaller messages

See `research/proto_benchmark/BENCHMARK_RESULTS.md` for full analysis.

## ğŸ—ï¸ Project Structure

```
proto2ffi/
â”œâ”€â”€ proto2ffi-core/           # Core library
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ parser/           # Proto parsing
â”‚   â”‚   â”œâ”€â”€ model/            # IR (Service, Method, Message)
â”‚   â”‚   â””â”€â”€ generator/        # Code generation
â”‚   â”‚       â”œâ”€â”€ rust/         # Rust FFI generator
â”‚   â”‚       â””â”€â”€ dart/         # Dart client generator
â”œâ”€â”€ proto2ffi-cli/            # CLI tool
â”œâ”€â”€ proto2ffi-runtime/        # Runtime support
â”‚   â”œâ”€â”€ rust/                 # Rust runtime
â”‚   â””â”€â”€ dart/                 # Dart runtime
â”œâ”€â”€ examples/
â”‚   â””â”€â”€ hello_world/          # Working example
â””â”€â”€ research/
    â””â”€â”€ proto_benchmark/      # Performance analysis
```

## ğŸ”¬ Research & Benchmarks

The `research/` directory contains comprehensive performance analysis:

- **proto_benchmark/**: FFI performance comparison
  - Single operation vs bulk benchmarks
  - Protobuf vs raw struct measurements
  - Memory efficiency analysis
  - Statistical analysis (min/median/avg/P95/P99)

Key insight: Protobuf-over-FFI is faster and more memory efficient than raw struct conversion for round-trip FFI operations.

## ğŸ¤ Contributing

Contributions are welcome! Areas for improvement:

- [ ] Streaming RPC support (client/server/bidirectional)
- [ ] Async/await support
- [ ] Error type generation
- [ ] Middleware/interceptors
- [ ] Code generation optimizations
- [ ] More examples

## ğŸ“„ License

This project is licensed under the MIT License - see the [LICENSE](./LICENSE) file for details.

## ğŸ™ Acknowledgments

- Protobuf libraries: [prost](https://github.com/tokio-rs/prost) (Rust), [protobuf.dart](https://pub.dev/packages/protobuf) (Dart)
- Proto parsing: [protobuf-parse](https://crates.io/crates/protobuf-parse)
- Inspired by gRPC's service-oriented approach
- Built for the Flutter + Rust ecosystem

## ğŸ“ Support

- ğŸ› [Issue Tracker](https://github.com/santoshakil/proto2ffi/issues)
- ğŸ’¬ [Discussions](https://github.com/santoshakil/proto2ffi/discussions)
- ğŸ“– [Documentation](https://docs.rs/proto2ffi)

## ğŸ”— Related Projects

- [flutter_rust_bridge](https://github.com/fzyzcjy/flutter_rust_bridge) - Alternative approach with custom serialization
- [gRPC](https://grpc.io/) - Network RPC (proto2ffi is FFI RPC)
- [prost](https://github.com/tokio-rs/prost) - Rust protobuf implementation

---

**Built with â¤ï¸ for high-performance Flutter + Rust applications**
