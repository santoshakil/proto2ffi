syntax = "proto3";

enum CodecType {
    H264 = 0;
    H265 = 1;
    VP8 = 2;
    VP9 = 3;
    AV1 = 4;
}

enum FrameType {
    I_FRAME = 0;
    P_FRAME = 1;
    B_FRAME = 2;
}

enum ChromaSubsampling {
    YUV420 = 0;
    YUV422 = 1;
    YUV444 = 2;
}

enum BufferState {
    EMPTY = 0;
    FILLING = 1;
    FULL = 2;
    DRAINING = 3;
}

message FrameMetadata {
    option (proto2ffi.pool_size) = 5000;

    uint64 timestamp_us = 1;
    uint64 pts = 2;
    uint64 dts = 3;
    FrameType frame_type = 4;
    uint32 frame_number = 5;
    bool keyframe = 6;
    uint32 width = 7;
    uint32 height = 8;
    uint32 bitrate = 9;
    float quality_score = 10;
}

message CodecParameters {
    option (proto2ffi.simd) = true;

    CodecType codec = 1;
    uint32 width = 2;
    uint32 height = 3;
    uint32 bitrate = 4;
    uint32 framerate = 5;
    uint32 gop_size = 6;
    ChromaSubsampling chroma = 7;
    uint32 bit_depth = 8;
    uint32 profile = 9;
    uint32 level = 10;
}

message VideoFrame {
    option (proto2ffi.pool_size) = 1000;

    FrameMetadata metadata = 1;
    repeated uint32 y_plane = 2 [(proto2ffi.max_count) = 8294400];
    repeated uint32 u_plane = 3 [(proto2ffi.max_count) = 2073600];
    repeated uint32 v_plane = 4 [(proto2ffi.max_count) = 2073600];
    uint32 y_stride = 5;
    uint32 u_stride = 6;
    uint32 v_stride = 7;
}

message CompressedFrame {
    option (proto2ffi.pool_size) = 2000;

    FrameMetadata metadata = 1;
    repeated uint32 data = 2 [(proto2ffi.max_count) = 1048576];
    uint32 data_size = 3;
    bool encrypted = 4;
}

message TimestampSync {
    option (proto2ffi.simd) = true;

    uint64 presentation_time = 1;
    uint64 decode_time = 2;
    uint64 capture_time = 3;
    uint64 render_time = 4;
    int64 av_offset_us = 5;
    int32 drift_compensation = 6;
}

message BufferPool {
    option (proto2ffi.pool_size) = 100;

    repeated uint32 buffer_ids = 1 [(proto2ffi.max_count) = 64];
    repeated BufferState buffer_states = 2 [(proto2ffi.max_count) = 64];
    uint32 total_buffers = 3;
    uint32 available_buffers = 4;
    uint32 used_buffers = 5;
    uint64 total_memory_bytes = 6;
}

message StreamStatistics {
    option (proto2ffi.simd) = true;

    uint64 frames_processed = 1;
    uint64 frames_dropped = 2;
    uint64 bytes_processed = 3;
    float average_bitrate = 4;
    float average_framerate = 5;
    uint32 buffer_underruns = 6;
    uint32 buffer_overruns = 7;
    float average_latency_ms = 8;
    float jitter_ms = 9;
}

message EncodingConfig {
    option (proto2ffi.simd) = true;

    CodecParameters params = 1;
    uint32 num_threads = 2;
    bool use_hardware_accel = 3;
    uint32 max_b_frames = 4;
    uint32 ref_frames = 5;
    bool use_cabac = 6;
    uint32 rate_control_mode = 7;
    uint32 qp_min = 8;
    uint32 qp_max = 9;
}

message DecodingResult {
    bool success = 1;
    uint32 decoded_frames = 2;
    uint64 decode_time_us = 3;
    uint32 errors = 4;
    string error_message = 5 [(proto2ffi.max_length) = 256];
}

message BitrateControl {
    option (proto2ffi.simd) = true;

    uint32 target_bitrate = 1;
    uint32 min_bitrate = 2;
    uint32 max_bitrate = 3;
    uint32 current_bitrate = 4;
    float buffer_fullness = 5;
    uint32 quantizer = 6;
    bool congestion_detected = 7;
}

message FrameBuffer {
    option (proto2ffi.pool_size) = 500;

    uint32 buffer_id = 1;
    BufferState state = 2;
    uint64 timestamp = 3;
    uint32 size = 4;
    repeated uint32 data = 5 [(proto2ffi.max_count) = 2097152];
}

message NetworkPacket {
    option (proto2ffi.pool_size) = 10000;

    uint32 sequence_number = 1;
    uint64 timestamp = 2;
    uint32 payload_size = 3;
    repeated uint32 payload = 4 [(proto2ffi.max_count) = 1500];
    bool marker_bit = 5;
}

message JitterBuffer {
    option (proto2ffi.pool_size) = 200;

    repeated uint32 packet_sequence = 1 [(proto2ffi.max_count) = 256];
    repeated uint64 packet_timestamps = 2 [(proto2ffi.max_count) = 256];
    uint32 buffer_size = 3;
    uint32 head_index = 4;
    uint32 tail_index = 5;
    uint32 missing_packets = 6;
}
