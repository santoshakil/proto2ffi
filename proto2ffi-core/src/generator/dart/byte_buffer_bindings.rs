use crate::error::{Error, Result};
use std::fs;
use std::path::Path;

pub fn generate(output_dir: &Path) -> Result<()> {
    let content = r#"// Generated by proto2ffi
// DO NOT EDIT

import 'dart:ffi' as ffi;
import 'dart:typed_data';

/// ByteBuffer FFI struct for passing protobuf bytes across FFI boundary
final class ByteBuffer extends ffi.Struct {
  external ffi.Pointer<ffi.Uint8> ptr;

  @ffi.Size()
  external int len;

  @ffi.Size()
  external int cap;

  /// Convert ByteBuffer to Dart Uint8List
  Uint8List toUint8List() {
    if (ptr == ffi.nullptr || len == 0) {
      return Uint8List(0);
    }
    return ptr.asTypedList(len);
  }
}

/// Free a ByteBuffer returned from Rust
typedef FreeByteBufferNative = ffi.Void Function(ByteBuffer);
typedef FreeByteBufferDart = void Function(ByteBuffer);
"#;

    let output_path = output_dir.join("byte_buffer.dart");
    fs::write(&output_path, content).map_err(|e| Error::Io(e))?;

    Ok(())
}
