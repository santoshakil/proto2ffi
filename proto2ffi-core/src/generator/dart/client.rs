use crate::error::{Error, Result};
use crate::model::ProtoService;
use std::fs;
use std::path::Path;

pub fn generate_client(service: &ProtoService, output_dir: &Path) -> Result<()> {
    let mut content = String::new();

    content.push_str("// Generated by proto2ffi\n");
    content.push_str("// DO NOT EDIT\n\n");

    content.push_str("import 'dart:ffi' as ffi;\n");
    content.push_str("import 'package:ffi/ffi.dart';\n\n");
    content.push_str("import 'byte_buffer.dart';\n\n");

    content.push_str(&format!("/// {} service client\n", service.name));
    content.push_str("///\n");
    content.push_str("/// This client provides a clean Dart API for calling the Rust service\n");
    content.push_str("/// via FFI with protobuf encoding.\n");
    content.push_str(&format!("class {}Client {{\n", service.camel_case_name()));
    content.push_str("  final ffi.DynamicLibrary _dylib;\n");

    for method in &service.methods {
        if !method.is_unary() {
            continue;
        }

        content.push_str(&format!("  late final _{};\n", method.snake_case_name()));
    }

    content.push_str("  late final FreeByteBufferDart _freeByteBuffer;\n\n");

    content.push_str(&format!("  {}Client(this._dylib) {{\n", service.camel_case_name()));

    for method in &service.methods {
        if !method.is_unary() {
            continue;
        }

        content.push_str(&format!(
            "    _{} = _dylib.lookupFunction<\n",
            method.snake_case_name()
        ));
        content.push_str("      ByteBuffer Function(ffi.Pointer<ffi.Uint8>, ffi.Size),\n");
        content.push_str("      ByteBuffer Function(ffi.Pointer<ffi.Uint8>, int)\n");
        content.push_str(&format!("    >('{}');\n\n", method.ffi_function_name()));
    }

    content.push_str("    _freeByteBuffer = _dylib.lookupFunction<\n");
    content.push_str("      FreeByteBufferNative,\n");
    content.push_str("      FreeByteBufferDart\n");
    content.push_str("    >('proto2ffi_free_byte_buffer');\n");
    content.push_str("  }\n\n");

    for method in &service.methods {
        if !method.is_unary() {
            continue;
        }

        content.push_str(&format!("  /// Call the {} RPC method\n", method.name));
        content.push_str("  ///\n");
        content.push_str(&format!("  /// Takes a {} protobuf message and returns a {} protobuf message.\n",
            method.input_type, method.output_type));
        content.push_str("  /// Returns null if the call fails.\n");
        content.push_str(&format!(
            "  List<int>? {}(List<int> requestBytes) {{\n",
            method.snake_case_name()
        ));

        content.push_str("    final requestPtr = malloc.allocate<ffi.Uint8>(requestBytes.length);\n");
        content.push_str("    requestPtr.asTypedList(requestBytes.length).setAll(0, requestBytes);\n\n");

        content.push_str(&format!(
            "    final result = _{}(requestPtr, requestBytes.length);\n",
            method.snake_case_name()
        ));

        content.push_str("    malloc.free(requestPtr);\n\n");

        content.push_str("    if (result.ptr == ffi.nullptr) {\n");
        content.push_str("      return null;\n");
        content.push_str("    }\n\n");

        content.push_str("    final responseBytes = result.toUint8List();\n");
        content.push_str("    _freeByteBuffer(result);\n\n");

        content.push_str("    return responseBytes;\n");
        content.push_str("  }\n\n");
    }

    content.push_str("}\n");

    let file_name = format!("{}_client.dart", service.snake_case_name());
    let output_path = output_dir.join(file_name);
    fs::write(&output_path, content).map_err(|e| Error::Io(e))?;

    Ok(())
}
