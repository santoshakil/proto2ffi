use crate::error::{Error, Result};
use crate::model::ProtoService;
use std::fs;
use std::path::Path;

pub fn generate_ffi_exports(service: &ProtoService, output_dir: &Path) -> Result<()> {
    let mut content = String::new();

    let file_name = format!("{}_ffi.rs", service.snake_case_name());

    content.push_str("// Generated by proto2ffi FFI exports\n");
    content.push_str("// DO NOT EDIT\n\n");

    content.push_str("use super::*;\n");
    content.push_str("use prost::Message;\n");

    let mut message_types = std::collections::HashSet::new();
    for method in &service.methods {
        message_types.insert(&method.input_type);
        message_types.insert(&method.output_type);
    }

    if !message_types.is_empty() {
        content.push_str("use crate::{");
        let types: Vec<&str> = message_types.iter().map(|s| s.as_str()).collect();
        content.push_str(&types.join(", "));
        content.push_str("};\n");
    }

    content.push_str("\n");

    content.push_str(&format!(
        "// Static service instance holder\n"
    ));
    content.push_str(&format!(
        "// You must call init_{}() before using the service\n",
        service.snake_case_name()
    ));
    content.push_str(&format!(
        "static mut {}_INSTANCE: Option<Box<dyn {}>> = None;\n\n",
        service.name.to_uppercase(),
        service.camel_case_name()
    ));

    content.push_str(&format!(
        "/// Initialize the {} service with your implementation\n",
        service.name
    ));
    content.push_str("#[no_mangle]\n");
    content.push_str(&format!(
        "pub unsafe extern \"C\" fn init_{}(service: Box<dyn {}>) {{\n",
        service.snake_case_name(),
        service.camel_case_name()
    ));
    content.push_str(&format!(
        "    {}_INSTANCE = Some(service);\n",
        service.name.to_uppercase()
    ));
    content.push_str("}\n\n");

    for method in &service.methods {
        if !method.is_unary() {
            continue;
        }

        content.push_str(&format!("/// FFI export for {}.{}\n", service.name, method.name));
        content.push_str("#[no_mangle]\n");
        content.push_str(&format!(
            "pub unsafe extern \"C\" fn {}(request_data: *const u8, request_len: usize) -> ByteBuffer {{\n",
            method.ffi_function_name()
        ));

        content.push_str("    if request_data.is_null() || request_len == 0 {\n");
        content.push_str("        return ByteBuffer { ptr: std::ptr::null_mut(), len: 0, cap: 0 };\n");
        content.push_str("    }\n\n");

        content.push_str(&format!(
            "    let service = match &{}_INSTANCE {{\n",
            service.name.to_uppercase()
        ));
        content.push_str("        Some(s) => s,\n");
        content.push_str("        None => return ByteBuffer { ptr: std::ptr::null_mut(), len: 0, cap: 0 },\n");
        content.push_str("    };\n\n");

        content.push_str("    let request_bytes = std::slice::from_raw_parts(request_data, request_len);\n\n");

        content.push_str(&format!(
            "    let request = match {}::decode(request_bytes) {{\n",
            method.input_type
        ));
        content.push_str("        Ok(r) => r,\n");
        content.push_str("        Err(_) => return ByteBuffer { ptr: std::ptr::null_mut(), len: 0, cap: 0 },\n");
        content.push_str("    };\n\n");

        content.push_str(&format!(
            "    let response = match service.{}(request) {{\n",
            method.snake_case_name()
        ));
        content.push_str("        Ok(r) => r,\n");
        content.push_str("        Err(_) => return ByteBuffer { ptr: std::ptr::null_mut(), len: 0, cap: 0 },\n");
        content.push_str("    };\n\n");

        content.push_str("    let mut response_bytes = Vec::new();\n");
        content.push_str("    if response.encode(&mut response_bytes).is_err() {\n");
        content.push_str("        return ByteBuffer { ptr: std::ptr::null_mut(), len: 0, cap: 0 };\n");
        content.push_str("    }\n\n");

        content.push_str("    ByteBuffer::from_vec(response_bytes)\n");
        content.push_str("}\n\n");
    }

    let output_path = output_dir.join(file_name);
    fs::write(&output_path, content).map_err(|e| Error::Io(e))?;

    Ok(())
}
