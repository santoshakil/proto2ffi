mod service_trait;
mod ffi_exports;
mod byte_buffer;

use crate::error::{Error, Result};
use crate::model::ProtoFile;
use std::fs;
use std::path::Path;

pub fn generate(proto_files: &[ProtoFile], output_dir: &Path) -> Result<()> {
    fs::create_dir_all(output_dir).map_err(|e| Error::Io(e))?;

    for proto_file in proto_files {
        generate_byte_buffer(output_dir)?;

        for service in &proto_file.services {
            service_trait::generate_service_trait(service, output_dir)?;
            ffi_exports::generate_ffi_exports(service, output_dir)?;
        }
    }

    generate_mod_file(proto_files, output_dir)?;

    Ok(())
}

fn generate_byte_buffer(output_dir: &Path) -> Result<()> {
    let content = byte_buffer::generate();
    let output_path = output_dir.join("byte_buffer.rs");
    fs::write(&output_path, content).map_err(|e| Error::Io(e))?;
    Ok(())
}

fn generate_mod_file(proto_files: &[ProtoFile], output_dir: &Path) -> Result<()> {
    let mut content = String::new();

    content.push_str("// Generated by proto2ffi\n");
    content.push_str("// DO NOT EDIT\n\n");

    content.push_str("pub mod byte_buffer;\n");
    content.push_str("pub use byte_buffer::ByteBuffer;\n\n");

    for proto_file in proto_files {
        for service in &proto_file.services {
            let module_name = service.snake_case_name();
            content.push_str(&format!("pub mod {};\n", module_name));
            content.push_str(&format!("pub use {}::*;\n\n", module_name));

            let ffi_module_name = format!("{}_ffi", module_name);
            content.push_str(&format!("pub mod {};\n", ffi_module_name));
            content.push_str(&format!("pub use {}::*;\n\n", ffi_module_name));
        }
    }

    let output_path = output_dir.join("mod.rs");
    fs::write(&output_path, content).map_err(|e| Error::Io(e))?;

    Ok(())
}
